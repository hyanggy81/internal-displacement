
library(caret)
library(glmnet)
library(dplyr)
library(openxlsx)
library(googlesheets4)

# Google Sheets 
gs4_auth()

sheet_url <- "https://docs.google.com/spreadsheets/d/1lh58bajIROF7b1ErqbvAvP-oWdC692ia8Eoul1Nvs_I"

data <- read_sheet(sheet_url)

#Data Preprocessing

# Standardize independent variables
data <- data %>%
  group_by(iso3) %>%
  mutate(across(c(HDI, Urbanization, GDPpc, SPEI, Vulnerability, PoliticalStability, HumanRights, AgeDependency), ~ scale(.)))

# Standardize Conflict and Disasters variables
data <- data %>%
  group_by(iso3) %>%
  mutate(
    Conflict_std = log((Conflict + 1) / (pop + 1)),
    Disasters_std = log((Disasters + 1) / (pop + 1))
  )

# Apply lag1
lagged_vars <- c("HDI", "Urbanization", "GDPpc", "SPEI", "Vulnerability", "HumanRights", "AgeDependency", "PoliticalStability", "Conflict_std", "Disasters_std", "GDPgrowth", "UrbanGrowth")
for (var in lagged_vars) {
  data[[paste0(var, "_lag1")]] <- ave(data[[var]], data$iso3, FUN = function(x) c(NA, x[-length(x)]))
}


# Define independent_vars
independent_vars <- c("HDI_lag1", "Urbanization_lag1", "GDPpc_lag1", "SPEI_lag1", "Vulnerability_lag1", "PoliticalStability_lag1", "HumanRights_lag1", "AgeDependency_lag1", "Conflict_std_lag1", "Disasters_std_lag1", "GDPgrowth_lag1", "UrbanGrowth_lag1")


# Convert independent variables to numeric
for(var in independent_vars) {
  data[[var]] <- as.numeric(as.character(data[[var]]))
}

# Log for dependent variables
data <- data %>%
  mutate(
    ID_conflict_log = log(ID_conflict + 1),
    ID_disasters_log = log(ID_disasters + 1), 
    IDPs_conflict_log = log(IDPs_conflict + 1),
    IDPs_disasters_log = log(IDPs_disasters + 1),
    ID_log = log(ID + 1),
    IDPs_log = log(IDPs + 1),
    refugee_log = log(refugee + 1)
  )

# Define dependent variable
dependent_var <- "ID_conflict_log"


# Select only the specified variables
input.df <- data[, c("iso3", "year", independent_vars, dependent_var)]


# Filter out NA rows 
input.df <- na.omit(input.df)


# Check the modified data
summary(input.df)

# Save selected data to Excel file
write.xlsx(input.df, "input.df.xlsx")






# Cross-validation


results <- list()

folds <- 4
test.horizon <- 1
alpha <- 0
lambda <- c(0, 1, 0.01)

# Iterate over each group (iso3) 
unique_iso3 <- unique(input.df$iso3)

for(iso3_code in unique_iso3) {
  cat("Processing country:", iso3_code, "\n")
  
  df_iso3 <- input.df %>% 
    filter(iso3 == iso3_code) %>% 
    arrange(year)
  
  factors_to_exclude <- sapply(df_iso3, function(x) if(is.factor(x)) length(unique(x)) == 1 else FALSE)
  variables_to_keep <- names(df_iso3)[!factors_to_exclude]
  
  # Setup the trainControl for time-series cross-validation
  initialWindow <- max(1, nrow(df_iso3) - folds - (test.horizon - 1))
  myTimeControl <- trainControl(method = "timeslice",
                                initialWindow = initialWindow,
                                horizon = test.horizon,
                                fixedWindow = TRUE,
                                allowParallel = TRUE,
                                savePredictions = "final")
  
  
  # Train the Elastic Net 
  model_formula <- as.formula(paste("ID_conflict_log ~", paste(variables_to_keep[!variables_to_keep %in% c("iso3", "year", "ID_conflict_log")], collapse = " + ")))
  model <- train(model_formula, 
                 data = df_iso3,
                 method = "glmnet",
                 trControl = myTimeControl,
                 tuneGrid = expand.grid(alpha = alpha, lambda = lambda),
                 metric = "RMSE")
  
  # Store the trained model and its details
  results[[iso3_code]] <- list(model = model)
}
warnings()

print(results)




# coefficients
all_coefs <- data.frame()

# Loop through each country's results
for(iso3_code in names(results)) {
  # Check if the model exists and is of class glmnet
  if (!is.null(results[[iso3_code]]$model) && "glmnet" %in% class(results[[iso3_code]]$model$finalModel)) {
    # Extract the final model
    model <- results[[iso3_code]]$model$finalModel
    
    # Get the coefficients at the best lambda (change s to a different value if needed)
    best_lambda <- results[[iso3_code]]$model$bestTune$lambda
    coefs <- coef(model, s = best_lambda)
    
    # Convert to a dataframe and add row names as a column
    coefs_df <- as.data.frame(as.matrix(coefs)) %>%
      tibble::rownames_to_column(var = "variable") %>%
      dplyr::filter(variable != "(Intercept)") %>%
      dplyr::mutate(iso3 = iso3_code) # Add the country code
    
    # Append this country's coefficients to the overall data frame
    all_coefs <- rbind(all_coefs, coefs_df)
  }
}


# Averaging the coefficients across all countries
average_coefs <- all_coefs %>%
  group_by(variable) %>%
  summarise(average = mean(s1, na.rm = TRUE)) %>%
  ungroup()


# Print average coefficients
print(average_coefs)

library(ggplot2)

# Plotting the average coefficients
ggplot(average_coefs, aes(x = reorder(variable, average), y = average)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() + # Flip the coordinates to make it horizontal
  theme_minimal() +
  labs( x = "Variable",
        y = "Average Coefficient")










